# ARTS Week 4
* Algorithm
  - [ID126 WordLadder](https://leetcode.com/problems/word-ladder-ii/)
 
* Review：关于单例Spring bean的讨论
* Tips：有向图环检测和DAG拓扑排序
* Share：数据库中事务概念与并发控制

## Algorithm
- code (https://github.com/drejrnal/arts/edit/master/Artsweek4/WordLadder.java)
- solution:本题涉及到的知识点是BFS和DFS;单词接龙涉及两个单词以最短距离的转换，每次转换只能变动一个字母，且转换目标必须是题中所给字典中的单词。
  - 对于每次变换只能变动一个单词，有两种方式，一种是遍历字典找出与待转换单词差一个字母的单词；此种方式面对字典数据集偏大的情况会出现超出时间限制的窘境，另外一种是对待转换单词进行local transform,每次变动一个位置，每个位置进行26种尝试。综合来讲第二种方式平均复杂度相对较低。
  - 题中最小距离很容易使我们想到利用广度优先搜索，但此题还要求返回所有满足条件的答案，因此还需采取深度优先搜索记录每一个合理路径。
    
  
## Review
关于单例Spring bean的讨论(https://dzone.com/articles/an-interview-question-on-spring-singletons)

文中通过一道面试题进一步解释了spring中单例bean的细节
具有不同ID的bean即使bean声明时的class相同，spring IOC容器仍会对不同ID产生不同实例。

## Tip
### 有向图的环检测及DAG拓扑排序
每次深度优先搜索过程中维护一个栈表示此次路径中已遍历到的节点，如果遍历过程中发现该节点已出现在栈中，则该节点就是环产生的终止节点。
拓扑排序是图后序遍历序列的逆序，因此每次深度优先搜索到达终止位置时将该节点放入栈中，最终栈中节点的序列即为拓扑序列。
```
private boolean[] marked;
private boolean[] onStack;vate boolean hasCycle;
private Stack<Integer> reversePostOrder;//存放拓扑排序序列
public void dfs(List<Integer>[] graph, int v) {
        marked[v] = true;
        onStack[v] = true; //一趟深度优先搜索过程中维护的栈
        if (graph[v]!=null) {
            for (int w : graph[v]) {
                if (hasCycle) return;
                else if (!marked[w]) dfs(graph, w);
                else if (onStack[w])
                    hasCycle = true;
            }
        }
        reversePostOrder.add(v);//
        onStack[v] = false;
    }
}
```

## Share:数据库事务概念和并发控制
### 基本概念
数据库中一些操作的集合被认为是一个独立的单元，事务就是访问可能更新各种数据项的程序执行单元，其基本性质就是原子性
当系统中存在多个事务需要执行时，就需要满足隔离性以保证数据库的一致性，一致性即指不管事务是并发执行还是串行执行结果是一致的。
类似于程序设计中我们习惯将大的程序拆分成多个子任务，利用硬件并行性从而提升程序执行效率，事务处理系统也需要并发处理多个事务：有的事务中既涉及CPU活动又涉及I/O活动，利用CPU和I/O的并行性，多个事务可以并发执行。当一个事务在磁盘上读写时，另一个事务可以在CPU上运行，第三个事务可在另一块磁盘上读写（例如RAID），这种活动增加了系统的吞吐量-即给定时间执行事务数增加。此外还提升了CPU利用率。
但是如果将事务并发执行时的调度完全交由操作系统负责，则极有可能导致数据库处于状态不一致，所以数据库系统需要提供并发控制机制。
### 有向无环图检测在并发控制中的应用
事务并发执行调度中，往往是对相同数据项执行读写操作时不同调度会产生不同的结果，这组指令称之为冲突指令。若一个调度S与一个串行调度等价则称S是冲突可串行化的。因此为保证调度室冲突串行化，可以利用有向图环检来判断，并利用拓扑排序得出最终调度顺序。
  - 事务T2执行Read(Q)前事务T1执行Write(Q)操作
  - 事务T2执行Write(Q)前事务T1执行Read(Q)操作
  - 事务T2执行Write(Q)前事务T1执行Write(Q)操作

上述任何一种调度会产生T1->T2的有向边，如果产生的有向图中有环则不能冲突可串行化，不应该发生此种调度。
有向图环检测亦可用于死锁检测中，死锁可以用成为等待图描述，同样顶点表示事务，边集之间的指向表示一个事务正在等待另一个事务释放锁：例如事务T2等待T1释放所需要的锁，则会有一条T2->T1的边，每当一个事务因需要获取锁而等待时，就往等待图中添加相应有向边，并检测图中是否出现环，若产生环，则需要采取相应恢复措施例如回滚事务来从死锁状态中恢复。
### 数据库并发控制中的锁
数据库并发控制中的锁分为共享锁和排它锁，有点类似程序设计中的读写锁，即允许多个事务并发读取同一数据项，但每次只保证有一个事务写数据项。此外保证可串行性的一个协议是两阶段封锁协议：增长阶段事务可以获取锁但不能释放锁；缩减阶段事务可以释放锁但不可以获得新锁。此外锁升级（共享到排他）只能发生在增长阶段；锁的降级（排他到共享）只能发生在降级阶段。
